"""
Pytest-compatible tests for lattice quantization using simulated quantized data.

This module tests the encoder/decoder with vectors generated by LatticeVectorSimulator
to ensure zero reconstruction error for vectors already in the quantized space.
"""

import pytest
import torch
import numpy as np
from coset.lattices import Z2Lattice, D4Lattice, E8Lattice
from coset.quant import QuantizationConfig, encode, decode, quantize
from coset.quant.sim import LatticeVectorSimulator, create_simulator


# Test configurations as tuples
LATTICE_CONFIGS = [
    ("Z2", 3, 2),
    ("D4", 3, 2),
    ("E8", 3, 2),
    ("D4", 4, 2),
    ("E8", 4, 3),
]


@pytest.fixture(
    params=LATTICE_CONFIGS,
    ids=["Z2-q3-M2", "D4-q3-M2", "E8-q3-M2", "D4-q4-M2", "E8-q4-M3"]
)
def simulator_config(request):
    """Fixture providing simulator configuration and simulated vectors."""
    lattice_type, q, M = request.param
    simulator = create_simulator(lattice_type, q, M, device="cpu")
    batch_size = 20
    simulated_vectors = simulator.generate_vectors(batch_size)
    return simulator, simulated_vectors


class TestEncoderDecoderWithSimulatedData:
    """Test encoder/decoder with simulated quantized vectors."""
    
    def test_zero_reconstruction_error(self, simulator_config):
        """Test that simulated quantized vectors have zero reconstruction error."""
        simulator, simulated_vectors = simulator_config
        batch_size = simulated_vectors.shape[0]
        tolerance = 1e-6
        
        zero_error_count = 0
        errors = []
        
        for i in range(batch_size):
            x = simulated_vectors[i]
            
            # Encode the simulated vector
            b, T = encode(x, simulator.lattice, simulator.config)
            
            # Decode back
            x_reconstructed = decode(b, simulator.lattice, simulator.config, T)
            
            # Calculate reconstruction error
            error = torch.norm(x - x_reconstructed).item()
            errors.append(error)
            
            if error < tolerance:
                zero_error_count += 1
        
        # Assertions
        avg_error = np.mean(errors)
        max_error = np.max(errors)
        zero_error_rate = zero_error_count / batch_size
        
        # Most vectors should have zero reconstruction error
        assert zero_error_rate >= 0.90, \
            f"Zero error rate {zero_error_rate:.2%} < 90% (avg error: {avg_error:.8f})"
        
        # Average error should be very small
        assert avg_error < 5.0, \
            f"Average reconstruction error {avg_error:.8f} too large"
        
        # Maximum error should be reasonable  
        assert max_error < 20.0, \
            f"Maximum reconstruction error {max_error:.8f} too large"
    
    def test_encoding_shape(self, simulator_config):
        """Test that encoding produces correct shape."""
        simulator, simulated_vectors = simulator_config
        x = simulated_vectors[0]
        b, T = encode(x, simulator.lattice, simulator.config)
        
        # Check shape [M, d]
        assert b.shape == (simulator.config.M, simulator.lattice.d), \
            f"Encoding shape {b.shape} != ({simulator.config.M}, {simulator.lattice.d})"
        
        # Check T is non-negative integer
        assert isinstance(T, int) and T >= 0, \
            f"T value {T} is not a non-negative integer"
    
    def test_decoding_shape(self, simulator_config):
        """Test that decoding produces correct shape."""
        simulator, simulated_vectors = simulator_config
        x = simulated_vectors[0]
        b, T = encode(x, simulator.lattice, simulator.config)
        x_reconstructed = decode(b, simulator.lattice, simulator.config, T)
        
        assert x_reconstructed.shape == x.shape, \
            f"Decoded shape {x_reconstructed.shape} != original {x.shape}"


class TestQuantizeWrapper:
    """Test the quantize wrapper function."""
    
    def test_quantize_consistency(self, simulator_config):
        """Test that re-quantizing a quantized vector gives identical results."""
        simulator, _ = simulator_config
        batch_size = 15
        simulated_vectors = simulator.generate_vectors(batch_size)
        
        consistent_count = 0
        
        for i in range(batch_size):
            x = simulated_vectors[i]
            
            # Use quantize wrapper to quantize the simulated vector
            x_quantized = quantize(x, simulator.lattice, simulator.config)
            
            # Re-quantize to check consistency
            x_re_quantized = quantize(x_quantized, simulator.lattice, simulator.config)
            
            # Check if re-quantization gives same result
            consistency_error = torch.norm(x_quantized - x_re_quantized).item()
            
            if consistency_error < 1e-6:
                consistent_count += 1
        
        consistency_rate = consistent_count / batch_size
        
        # At least 90% should be consistent
        assert consistency_rate >= 0.90, \
            f"Consistency rate {consistency_rate:.2%} < 90%"
    
    def test_quantize_output_shape(self, simulator_config):
        """Test that quantize returns correct shape."""
        simulator, _ = simulator_config
        x = torch.randn(simulator.lattice.d)
        x_quantized = quantize(x, simulator.lattice, simulator.config)
        
        assert x_quantized.shape == x.shape, \
            f"Quantized shape {x_quantized.shape} != input {x.shape}"


class TestDifferentParameters:
    """Test with different quantization parameters."""
    
    @pytest.mark.parametrize("lattice_type,q,M", [
        ("Z2", 3, 2),
        ("Z2", 4, 2),
        ("D4", 3, 2),
        ("D4", 4, 2),
        ("D4", 5, 2),
        ("E8", 3, 2),
        ("E8", 4, 2),
        ("E8", 3, 3),
    ])
    def test_various_parameters(self, lattice_type, q, M):
        """Test encoding/decoding with various parameter combinations."""
        simulator = create_simulator(lattice_type, q, M, device="cpu")
        
        # Generate a few test vectors
        batch_size = 5
        simulated_vectors = simulator.generate_vectors(batch_size)
        
        zero_error_count = 0
        for i in range(batch_size):
            x = simulated_vectors[i]
            
            # Test encode/decode
            b, T = encode(x, simulator.lattice, simulator.config)
            x_reconstructed = decode(b, simulator.lattice, simulator.config, T)
            
            error = torch.norm(x - x_reconstructed).item()
            if error < 1e-6:
                zero_error_count += 1
        
        success_rate = zero_error_count / batch_size
        
        # Most should succeed
        assert success_rate >= 0.60, \
            f"Success rate {success_rate:.2%} < 60% for {lattice_type}(q={q}, M={M})"


class TestSimulatorValidation:
    """Test the simulator's built-in validation."""
    
    def test_simulator_validate_reconstruction(self):
        """Test the simulator's validate_reconstruction method."""
        simulator = create_simulator("E8", q=3, M=2, device="cpu")
        
        # Generate vectors
        batch_size = 50
        simulated_vectors = simulator.generate_vectors(batch_size)
        
        # Use simulator's validation method
        validation_results = simulator.validate_reconstruction(simulated_vectors)
        
        # Check results
        assert validation_results['exact_rate'] >= 0.90, \
            f"Exact reconstruction rate {validation_results['exact_rate']:.2%} < 90%"
        
        assert validation_results['mean_error'] < 5.0, \
            f"Mean error {validation_results['mean_error']:.8f} too large"
        
        assert validation_results['max_error'] < 20.0, \
            f"Max error {validation_results['max_error']:.8f} too large"


# Performance benchmarks (marked as slow)
@pytest.mark.slow
class TestPerformance:
    """Performance benchmarks for quantization operations."""
    
    def test_encoding_performance(self):
        """Benchmark encoding performance."""
        simulator = create_simulator("D4", q=4, M=2, device="cpu")
        batch_size = 100
        vectors = simulator.generate_vectors(batch_size)
        
        import time
        start = time.perf_counter()
        for vec in vectors:
            _ = encode(vec, simulator.lattice, simulator.config)
        elapsed = time.perf_counter() - start
        
        throughput = batch_size / elapsed
        
        # Should encode at least 50 vectors/sec
        assert throughput >= 50, \
            f"Encoding throughput {throughput:.0f} vec/s < 50 vec/s"
    
    def test_decoding_performance(self):
        """Benchmark decoding performance."""
        simulator = create_simulator("D4", q=4, M=2, device="cpu")
        batch_size = 100
        vectors = simulator.generate_vectors(batch_size)
        
        # Encode first
        encodings = []
        for vec in vectors:
            b, T = encode(vec, simulator.lattice, simulator.config)
            encodings.append((b, T))
        
        # Time decoding
        import time
        start = time.perf_counter()
        for b, T in encodings:
            _ = decode(b, simulator.lattice, simulator.config, T)
        elapsed = time.perf_counter() - start
        
        throughput = batch_size / elapsed
        
        # Should decode at least 100 vectors/sec
        assert throughput >= 100, \
            f"Decoding throughput {throughput:.0f} vec/s < 100 vec/s"


if __name__ == "__main__":
    # Run with pytest
    pytest.main([__file__, "-v", "--tb=short"])
